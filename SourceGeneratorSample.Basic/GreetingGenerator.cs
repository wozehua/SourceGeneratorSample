namespace SourceGeneratorSample.Basic;


/// <summary>
/// ISourceGenerator 要引用 microsoft.codeanalysis.common
/// 表示一个源代码生成器，生成一个类型，自带一个打招呼的方法。
/// </summary>
/// <remarks>
/// 备注，summary东西太多可以写在备注中。
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class GreetingGenerator : ISourceGenerator
{
    //inheritdoc 文档注释,给类型成员提供文字信息。
    //inheritdoc 这个使用的是基类派生下来的文档注释。
    //global::System.Runtime.CompilerServices.CompilerGeneratedAttribute 告知这段代码是由编译器生成的。
    //gloabl::System.CodeDom.Compiler.GeneratedCodeAttribute 告知这个是由哪个编译器模块生成的。
    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        //获取 Main 方法。 Microsoft.CodeAnalysis.Compilation.GetEntryPoint 方法返回程序的入口点的 IMethodSymbol
        var mainMethod = context.Compilation.GetEntryPoint(context.CancellationToken);
        var typeName=mainMethod.ContainingType.Name;
        context.AddSource($"{typeName}.g.cs",
    $$"""

    //告知编译器，该文件由源代码或别的手段生成产生的代码。
    //这样可以防止编译器对这个代码进行代码分析，避免不必要的编译器警告或普通信息提示。
    //<auto-generated/>

    //启用可空性检查。为 C# 8 提供的特性 “可空引用类型”的单文件启用写法。
    #nullable enable 

    //命名空间的声明。
    namespace  GreetingTest
    {

    /// <summary>
    /// 用于打招呼的代码
    /// </summary>
    /// <param name="name">表示对谁打招呼。指定一个字符串，表示其人的名字。</param>
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{nameof(GreetingGenerator)}}","1.0")]
    public static class Greeting
    {
        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{nameof(GreetingGenerator)}}","1.0")]
        public static void SayHelloTo(string name)=>global::System.Console.WriteLine($"Hello,{name}");
    }
    }
    """);
    }

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        
    }
}

